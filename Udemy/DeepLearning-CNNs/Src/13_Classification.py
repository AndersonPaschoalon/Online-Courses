# -*- coding: utf-8 -*-
"""13_Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13bAMnE0YOG3k3P5lniFqsWAu0FxfFEVj

# Linear Classification
"""

from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split
import numpy as np
import matplotlib.pyplot as plt
# model
from tensorflow.keras.layers import Input, Dense
from tensorflow.keras.models import Model
# normalization
from sklearn.preprocessing import StandardScaler
# tensorflow
import tensorflow as tf

out_dir = "13"
data = load_breast_cancer()
X_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.33)

# test
print(f"data.feature_names:{data.feature_names}")

# test
index = np.where(data.feature_names == 'mean compactness')[0][0]
sample = data.data[:, index]
plt.clf()
plt.title('mean compactness')
plt.plot(sample)
# plt.show()
plt.savefig(f"{out_dir}/mean_compactness")

N, D = X_train.shape
print(f"N:{N}, D:{D}")

scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# create the model
N, D = X_train.shape
i = Input(shape=(D,))
x = Dense(1, activation='sigmoid')(i)
model = Model(i, x)
model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

r = model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=100)

plt.clf()
plt.plot(r.history['loss'], label='loss')
plt.plot(r.history['val_loss'], label='val_loss')
plt.legend()
plt.savefig(f"{out_dir}/loss_iteration")

plt.clf()
plt.plot(r.history['accuracy'], label='acc')
plt.plot(r.history['val_accuracy'], label='val_acc')
plt.legend()
plt.savefig(f"{out_dir}/accuracy_iteration")

"""# Making Predictions"""

# make predictions
P = model.predict(X_test)
# tget are outputs interpreted as probabilities p(y = 1 | x)
print("P.shape:", P.shape)

# Round to get the actual prediction
# note: has to be flattened since the targets are size (N, ) while the predictions are size (N, 1)
# before [[a] [b] [c]] , after [a b c]
P = np.round(P).flatten()
print(P)
print(y_test)

# calculate the accuracy, compare it ot evaluate() output
print("Manually calculated accuracy:", np.mean(P == y_test))
print("Evalueate accuracy:",  model.evaluate(X_test, y_test)[1])

"""# Saving and Loading a Model"""

model_path = f"{out_dir}/classification_model.h5"
model.save(model_path)

model = tf.keras.models.load_model(model_path)
print(model.layers)
model.evaluate(X_test, y_test)